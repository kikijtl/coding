这道题其实可以用类似于Maximum Gap的思想来做：
把0~X这X+1个格子按照每个bin长为D+1等分，共N = (X+1)/(D+1)个bin（不是整数的话取ceil）。
因为青蛙最大能够跳过D的距离，所以：
1. 在同一个bin内的任意两片叶子肯定能跳过，
2. 中间隔了一个或以上bin的两片叶子肯定无法直接跳过（即青蛙必定要从一个bin跳到相邻的bin，不可能跨bin跳）
因此，青蛙必定要在这N个bin之间跳正好N-1次（这以外的跳跃都是发生在bin内部，所以就不管了），才能到达X。
我们只要看这N个bin间是不是建立起了N-1次联系就可以了。
为此，我们给每个bin维护一个min和max值。
每次加入一片叶子，就更新其对应bin的min/max值。
然后检查：是否因为这个叶子加入，使得该bin和其相邻的bin能够建立起联系。
如果是的话，“联系”值++。最后，能够跳到X的充要条件是“联系”值==N-1。
该算法将每片叶子放入bin，检查与周围bin的连接情况等都是O(1)操作，因此最后总复杂度是O(arrLen)。
空间复杂度则是O(X/D)。